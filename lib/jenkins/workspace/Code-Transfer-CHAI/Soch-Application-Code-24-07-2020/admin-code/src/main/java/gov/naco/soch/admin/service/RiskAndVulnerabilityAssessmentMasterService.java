package gov.naco.soch.admin.service;

import java.util.ArrayList;
import java.util.List;

import javax.transaction.Transactional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import gov.naco.soch.dto.ErrorDto;
import gov.naco.soch.dto.ErrorResponse;
import gov.naco.soch.dto.RiskAndVulnerabilityAssessmentMasterDto;
import gov.naco.soch.entity.RiskAndVulnerabilityAssessmentMaster;
import gov.naco.soch.exception.ServiceException;
import gov.naco.soch.mapper.Constants;
import gov.naco.soch.mapper.RiskAndVulnerabilityAssessmentMasterMapper;
import gov.naco.soch.repository.RiskAndVulnerabilityAssessmentMasterRepository;
import gov.naco.soch.util.CommonConstants;

@Transactional
@Service
public class RiskAndVulnerabilityAssessmentMasterService {

	@Autowired
	private RiskAndVulnerabilityAssessmentMasterRepository r_VAssessmentMasterRepo;

	// Logger method
	private static final Logger logger = LoggerFactory.getLogger(RiskAndVulnerabilityAssessmentMasterService.class);

	// Function to select all GitStatus details from database
	public List<RiskAndVulnerabilityAssessmentMasterDto> getAllAssessmentNames() {
		logger.debug("findAll method called to fetch all values from RiskAndVulnerabilityAssessmentMaster Table");
		List<RiskAndVulnerabilityAssessmentMaster> assessmentNames = (List<RiskAndVulnerabilityAssessmentMaster>) r_VAssessmentMasterRepo
				.findAll();
		return RiskAndVulnerabilityAssessmentMasterMapper.mapToRiskAndVulnerabilityAssessmentDtoList(assessmentNames);
	}

	// Function to save GitStatus details to database
	public RiskAndVulnerabilityAssessmentMasterDto saveAssessmentName(
			RiskAndVulnerabilityAssessmentMasterDto r_v_assessmentDto) {

		int count = 0;
		boolean isEdit = false;

		if (r_v_assessmentDto.getId() != null && r_v_assessmentDto.getId() != 0) {

			count = r_VAssessmentMasterRepo.existsByRiskAndVulnerabilityAssessmentNameInEdit(
					r_v_assessmentDto.getRiskAndVulnerabilityAssessmentName(), r_v_assessmentDto.getId());
			logger.debug("existsByRiskAndVulnerabilityAssessmentNameInEdit method returns with Count ", count);
			isEdit = true;

		} else {
			logger.debug("existsByOtherGitStatusNameInAdd method called");
			count = r_VAssessmentMasterRepo.existsByRiskAndVulnerabilityAssessmentNameInAdd(
					r_v_assessmentDto.getRiskAndVulnerabilityAssessmentName());
			logger.debug("existsByRiskAndVulnerabilityAssessmentNameInAdd method returns with Count ", count);
		}

		// Handling exception for duplication of gitStatusName field and sending a
		// valid
		// error response JSON to UI layer
		if (count != 0) {
			logger.error(Constants.DUPLICATE_FOUND);
			String errorfield = "riskAndVulnerabilityAssessmentName";

			logger.debug("call throwError if duplicate found");
			throwError(errorfield, r_v_assessmentDto.getRiskAndVulnerabilityAssessmentName());
		}

		RiskAndVulnerabilityAssessmentMaster riskAndVulnerabilityAssessment = null;

		if (isEdit) {
			logger.debug("findById method called for find values of particular riskAndVulnerabilityAssessment");
			riskAndVulnerabilityAssessment = r_VAssessmentMasterRepo.findById(r_v_assessmentDto.getId()).get();
			logger.debug("findById method returns with entity values ", riskAndVulnerabilityAssessment);
		}

		logger.debug("mapToGitStatusEntity method called for convert Dto to entity for gitStatusDto");
		riskAndVulnerabilityAssessment = RiskAndVulnerabilityAssessmentMasterMapper
				.mapToRiskAndVulnerabilityAssessmentMaster(r_v_assessmentDto, riskAndVulnerabilityAssessment);
		logger.debug("mapToRiskAndVulnerabilityAssessmentMaster method return entity riskAndVulnerabilityAssessment",
				riskAndVulnerabilityAssessment);

		logger.debug("save method called for save values of riskAndVulnerabilityAssessment to DB");
		// Code segment to save riskAndVulnerabilityAssessment if duplicates are not
		// found
		riskAndVulnerabilityAssessment = r_VAssessmentMasterRepo.save(riskAndVulnerabilityAssessment);
		logger.debug("save method return entity riskAndVulnerabilityAssessment", riskAndVulnerabilityAssessment);

		logger.debug("mapToGitStatusDto method called for convert entity to Dto for gitStatus");
		r_v_assessmentDto = RiskAndVulnerabilityAssessmentMasterMapper
				.mapToRiskAndVulnerabilityAssessmentMasterDto(riskAndVulnerabilityAssessment);
		logger.debug("mapToGitStatusDto method return Dto r_v_assessmentDto", r_v_assessmentDto);

		return r_v_assessmentDto;
	}

	/**
	 * Method to throw error in case of validation errors
	 * 
	 * @param errorfield
	 * @param gitStatusName
	 */
	private void throwError(String errorfield, String errorFieldValue) {
		List<ErrorDto> errorDtoList = new ArrayList<>();
		List<String> detailsSimplified = new ArrayList<String>();
		ErrorDto errorDto = new ErrorDto();
		errorDto.setField(errorfield);
		errorDto.setDescription(Constants.DUPLICATE_FOUND + "'" + errorFieldValue + "'");
		errorDtoList.add(errorDto);
		detailsSimplified.add(errorDto.getDescription());
		ErrorResponse errorResponse = new ErrorResponse(CommonConstants.VALIDATION_FAILED, errorDtoList,
				detailsSimplified);
		throw new ServiceException(Constants.DUPLICATE_FOUND + " '" + errorFieldValue + "' ", errorResponse,
				HttpStatus.BAD_REQUEST);
	}

}
